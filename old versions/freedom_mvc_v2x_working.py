'''
Project initiation date: December 22 2017
Author: Wouter Haaxman
Copyright: None

useful links (used/tweaked parts to implement here):
https://www.pygame.org/docs
http://programarcadegames.com/python_examples/f.php?file=bullets.py
https://www.soundjay.com/gun-sound-effect.html(source of gunshot sound)
https://www.youtube.com/watch?v=3RJx34kGRGk (start menu tutorial)
https://www.youtube.com/watch?v=jh_m-Eytq0Q (buttons in start menu)
https://images.fineartamerica.com/images-medium-large/lieutenant-general-george-patton-left-everett.jpg (image patton)
http://ezide.com/games/writing-games.html#hModel(restructuring code to implement MVC & Mediator design patterns)
http://www.pygame.org/pcr/box_selection/index.php(code for unit selection box, I made my own in the pre-MVC version (which looks nicer
graphically) but the code for this one seems more organized, plus I did not know of the MOUSEMOTION event.)

Syntax rules (for practice in following rules):
Classes: Words joined together, each word starts with an upper-case letter.
Methods: Words joined together, each word starts with an upper-case letter.
Functions: Words joined together, first word starts with a lower-case letter.
Objects: Words joined together, first word starts with a lower-case letter.
Attributes&Variables: Words seperated by an underscore (_), first word start with a lower-case letter.
'''
import sys
import math
import pygame
from pygame.locals import *
                                #------------------COLOR DEFINITIONS------------
color_black = pygame.Color(0,0,0,255)
color_white = pygame.Color(255, 255, 255)
color_red = pygame.Color(255,0,0)
color_green = pygame.Color(0,255,0)
color_blue = pygame.Color(0,0,255)
color_freedom_start_menu = pygame.Color(150,150,150)
inact_color_start_Btn = pygame.Color(200,200,200)
inact_color_quit_Btn = pygame.Color(200,200,200)
act_color_start_Btn = pygame.Color(100,100,100)
act_color_quit_Btn = pygame.Color(100,100,100)
                                #------------------WINDOW SIZE------------------
display_pixel_width = 700
display_pixel_height = 546

def debug(message):
    print(message)

#----------------------------EVENT CLASSES--------------------------------------

class Event:
    '''this is a superclass for any events that might be generated by an
    object and sent to the EventManager'''
    def __init__(self):
        self.name = "Generic Event"

class TickEvent(Event):
	def __init__(self):
		self.name = "Iteration Tick Event"

class QuitEvent(Event):
	def __init__(self):
		self.name = "Program Quit Event"
                                        #----GAME STATE EVENTS------------------
class GameStartedEvent(Event):
    def __init__(self, game):
        self.name = "Game Started Event"
        self.game = game

class GamePausedEvent(Event):
    '''Not implemented yet'''
    def __init__(self, game):
        self.name = "Game Paused Event"
        self.game = game
                                        #----UNIT EVENTS------------------------
class UnitSpawnEvent(Event):
    '''this event occurs when a unit is spawned'''
    def __init__(self, unit):
        self.name = "Unit Spawn Event"
        self.unit = unit

class UnitMoveRequest(Event):
    '''
    To be implemented for right click movement of units.
    '''
    def __init__(self):
        self.name = "Unit Move Event"
        self.unit = unit
        self.destination = destination

class UnitMoveEvent(Event):
    '''To be implemented for right click movement of units.'''
    def __init__(self, unit):
        self.name = "Unit Spawn Event"
        self.unit = unit

class UnitShootBulletRequest(Event):
    def __init__(self, shoot_to_xy):
        self.name = "Request for Creation of/Shooting a bullet"
        self.shoot_to_xy = shoot_to_xy

class UnitShootBulletEvent(Event):
    def __init__(self, unit, shoot_to_xy):
        self.name = "Unit Shoot Bullet Event"
        self.unit = unit
        self.shoot_to_xy = shoot_to_xy
                                        #----OTHER EVENTS/REQUESTS--------------
class GetMousePositionRequest(Event):
    def __init__(self, initial_xy):
        self.name = "Get Mouse Position Request"
        self.initial_xy = initial_xy

#----------------------------MEDIATOR-------------------------------------------

class EventManager:
    '''
    From http://ezide.com/games/writing-games.html#hModel:
    We implement the Mediator pattern by creating an EventManager object.
    This middleman will allow multiple listeners to be notified when some other object changes state.
    Furthermore, that changing object doesn't need to know how many listeners there are, they can even
    be added and removed dynamically. All the changing object needs to do is send an Event to the
    EventManager when it changes.If an object wants to listen for events, it must first register
    itself with the EventManager. We'll use the weakref WeakKeyDictionary so that listeners don't
    have to explicitly unregister themselves.We will also create an Event class to encapsulate
    the events that can be sent via the EventManager.

    This object is responsible for coordinating most communication
	between the Model, View, and Controller
    '''
    def __init__(self):
        from weakref import WeakKeyDictionary
        self.listeners = WeakKeyDictionary()
        self.eventQueue = []

    def RegisterListener(self, listener):
        self.listeners[ listener ] = 1

    def UnRegisterListener(self, listener):
        if listener in self.listeners:
            del self.listeners[ listener ]

    def Post(self, event):
        if not isinstance(event, TickEvent):
            debug("Message: " + event.name)
        for listener in self.listeners:
            #Note: If the weakref has died, it will be
			#automatically removed, so we don't have
			#to worry about it.
            listener.Notify( event )

#----------------------------CONTROLLERS----------------------------------------

class KeyBoardController:
    '''
    KeyboardController takes Pygame events generated by the
	keyboard and uses them to control the model, by sending Requests
	or to control the Pygame display directly, as with the QuitEvent.
    '''
    def __init__(self, evManager):
        self.evManager = evManager
        self.evManager.RegisterListener( self )

    def Notify(self, event):
        if isinstance(event, TickEvent):
            #Handle input events
            for event in pygame.event.get():
                ev = None
                if event.type == QUIT:
                    ev = QuitEvent()
                                #------------------KEYBOARD---------------------
                elif event.type == KEYDOWN \
                    and event.key == K_SPACE:
                        #Send with the request a point that lies on the
                        #bullet trajectory line
                        shoot_to_xy = pygame.mouse.get_pos()
                        ev = UnitShootBulletRequest( shoot_to_xy )
                                #------------------MOUSE------------------------
                elif event.type == MOUSEBUTTONDOWN \
                    and pygame.mouse.get_pressed()[0] == 1:
                        initial_xy = pygame.mouse.get_pos()
                        ev = GetMousePositionRequest( initial_xy )

                if ev:
                    self.evManager.Post( ev )

#---------------------------------------

class IterationController:
    '''
    Equivalent of the CPUspinnerController in:
    http://ezide.com/games/writing-games.html#hModel
    '''
    def __init__(self, evManager):
        self.evManager = evManager
        self.evManager.RegisterListener(self)

        self.keep_going = 1
                                #------------------FRAMERATE--------------------
        self.FPS = 30 # frames per second setting
        self.fpsClock = pygame.time.Clock()

    def Run(self):
        while self.keep_going:
            event = TickEvent()
            self.evManager.Post( event )
            self.fpsClock.tick(self.FPS) #Added to implement FPS for single player mode. (slows down compared to CPU speed)

    def Notify(self, event):
        if isinstance(event, QuitEvent):
            #this will stop the while loop from running
            self.keep_going = 0


#-------------------------------VIEW SUPPORTING CLASSES-------------------------

class UnitSprite(pygame.sprite.Sprite):
    def __init__(self, unit, group = None):
        super().__init__()

        self.image = pygame.image.load('images/unit_unselected.png').convert() #image object is a surfaceS

        self.rect = self.image.get_rect()
        self.rect.centerx = unit.current_x
        self.rect.centery = unit.current_y

        self.is_selected = 0 # Used in the unitSelection function. Enabling movement & weapons.
        self.moveTo = None

    def update(self):
        if self.moveTo:
            '''
            implement right click unit movement to new position here.
            And in PygameView.MoveUnit
            '''
            pass

class BulletSprite(pygame.sprite.Sprite):
    def __init__(self, unit, shoot_to_xy):
        super().__init__()
        #Create soldier sprite and resize it.
        self.image = pygame.image.load('images/bullet.png').convert()
        self.size = self.image.get_size() # return a width and height of the image
        self.image = pygame.transform.scale(self.image, (int(self.size[0]*0.2), int(self.size[1]*0.2)))

        self.rect = self.image.get_rect()
        self.rect.centerx = unit.current_x
        self.rect.centery = unit.current_y
        self.shoot_to_x = shoot_to_xy[0]
        self.shoot_to_y = shoot_to_xy[1]

        self.dx = self.shoot_to_x - self.rect.centerx
        self.dy = self.shoot_to_y - self.rect.centery
        self.length = math.sqrt( self.dx**2 + self.dy**2 )
        self.factor = 10
                                #----------PLAY GUN SOUND UPON CREATION---------
        sound_gunshot = pygame.mixer.Sound('sounds/gunshot.ogg')
        sound_gunshot.play()

    def update(self):
        """ Move the bullet. """
        self.rect.x += self.factor*(self.dx/self.length)
        self.rect.y += self.factor*(self.dy/self.length)

#-------------------------------VIEW--------------------------------------------
class PygameView:
    '''
    '''
    def __init__(self, evManager):
        self.evManager = evManager
        self.evManager.RegisterListener( self )
                                #------------------INITIALIZE PYGAME------------
        pygame.init()
                                #-------------------DEFINE DISPLAY SCREEN-------
        self.window = pygame.display.set_mode( (display_pixel_width, display_pixel_height) )
        pygame.display.set_caption( 'Freedom' )
        self.background = pygame.Surface( self.window.get_size() )
        self.background.fill( color_white )
        self.window.blit( self.background, (0,0) )
                                #-------------------SPRITE LISTS----------------
        self.all_sprites_list = pygame.sprite.RenderUpdates()
        self.bullet_list = pygame.sprite.RenderUpdates()
        self.unit_list = pygame.sprite.RenderUpdates()
                                #------------------UPDATE DISPLAY SURF TO SCREEN
        pygame.display.flip()

    def SpawnUnit(self, unit):
        Unit_Sprite = UnitSprite( unit )
        self.unit_list.add( Unit_Sprite )
        self.all_sprites_list.add( Unit_Sprite ) # Add sprite to lists so that they are shown in window

    def UnitShootBullet(self, unit, shoot_to_xy):
        Bullet_Sprite = BulletSprite( unit, shoot_to_xy )
        self.bullet_list.add( Bullet_Sprite )
        self.all_sprites_list.add( Bullet_Sprite )

    def MoveUnit(self, unit):
        '''
        Implement right click unit movement code here. And in:
        UnitSprite.Update
        '''
        pass

    def Notify(self, event):
        if isinstance(event, TickEvent):
            #Draw everything
            #self.background.fill( color_white )
            #self.window.blit( self.background, (0,0) )
            self.all_sprites_list.clear( self.window, self.background )
            self.all_sprites_list.update() #Calls update method on all sprites in the list
            dirtyRects = self.all_sprites_list.draw( self.window )
            pygame.display.update(dirtyRects)
            '''Last 2 lines above give same result as:
            self.all_sprites_list.draw( self.window )
            pygame.display.flip()
            '''

        elif isinstance(event, UnitSpawnEvent):
            self.SpawnUnit( event.unit )

        elif isinstance(event, UnitMoveEvent):
            self.MoveUnit( event.unit )

        elif isinstance(event, UnitShootBulletEvent):
            self.UnitShootBullet( event.unit, event.shoot_to_xy )


#--------------------------------MODEL------------------------------------------
class Game:
    '''
    '''
    STATE_PREPAIRING = 'prepairing'
    STATE_RUNNING = 'running'
    STATE_PAUSED = 'paused'

    def __init__(self, evManager):

        self.evManager = evManager
        self.evManager.RegisterListener( self )

        self.state = Game.STATE_PREPAIRING

        self.players = [ Player( evManager ) ]

    def Start(self):
        self.state = Game.STATE_RUNNING
        ev = GameStartedEvent( self )
        self.evManager.Post( ev )

    def Pause(self):
        '''
        Not implemented yet
        '''
        self.state = Game.STATE_PAUSED
        ev = GamePausedEvent( self )
        self.evManager.Post( ev )

    def Notify(self, event):
        if isinstance(event, TickEvent):
            if self.state == Game.STATE_PREPAIRING:
                self.Start()

#---------------------------------------

class Player:
    '''
    '''
    def __init__(self, evManager):
        self.evManager = evManager
        self.game = None
        self.name = ''
        self.evManager.RegisterListener( self )

        self.units = [ Unit( evManager ) ]

    def __str__(self):
        return '<Player %s %s>' % (self.name, id(self))

    def Notify(self, event):
        pass

#---------------------------------------

class Unit:
    '''
    '''
    STATE_INACTIVE = 0
    STATE_ACTIVE = 1
    IS_NOT_SHOOTING = 0
    IS_SHOOTING = 1
    IS_NOT_SELECTED = 0
    IS_SELECTED = 1

    def __init__(self, evManager):

        self.evManager = evManager
        self.evManager.RegisterListener( self )

        self.state = Unit.STATE_INACTIVE
        self.shooting = Unit.IS_NOT_SHOOTING
        self.current_x = int(display_pixel_width/2)
        self.current_y = int(display_pixel_height/2)
        self.go_to_x = None
        self.go_to_y = None
        self.is_selected = Unit.IS_NOT_SELECTED

    def __str__(self):
        return '<Unit %s>' % id(self)

    def Spawn(self):
        self.state = Unit.STATE_ACTIVE
        ev = UnitSpawnEvent( self )
        self.evManager.Post( ev )

    def Move(self):
        '''
        To be implement for right click move to position. And in:
        PygameView.MoveUnit
        UnitSprite.Update
        '''
        if self.state == Unit.STATE_INACTIVE:
            return
        pass

    def UnitShootBullet(self, shoot_to_xy):
        if self.state == Unit.STATE_INACTIVE:
            return
        self.shooting = Unit.IS_SHOOTING
        ev = UnitShootBulletEvent( self, shoot_to_xy )
        self.evManager.Post( ev )

    def Notify(self, event):
        if isinstance(event, GameStartedEvent):
            '''
            Code to spawn units at certain locations can go here, then take out
            the initial position defined in the UnitSprite class.
            '''
            self.Spawn()

        elif isinstance(event, UnitMoveRequest):
            pass
            #self.Move( event.destination )

        elif isinstance(event, UnitShootBulletRequest):
            self.UnitShootBullet( event.shoot_to_xy )


#----------------------------BOOT-UP--------------------------------------------
def main():
    '''
    decoupled pieces of code that make up the game, all taking the Event manager.
    '''
    global View_Pygame
    evManager = EventManager()

    Cntrlr_Keyboard = KeyBoardController( evManager )
    Cntrlr_Iterator = IterationController( evManager )
    View_Pygame = PygameView( evManager)
    game = Game( evManager )

    Cntrlr_Iterator.Run()

if __name__ == '__main__':
    main()
